import logging
from datetime import datetime, timedelta
from django.utils import timezone
from django.contrib.auth.models import User
from .models import AutomationConfig, AutomationExecutionLog, BrokerCredentials, Strategy
from .services import BrokerService
from .telegram_notifications import TelegramNotifier

logger = logging.getLogger(__name__)

class AutomationService:
    """Service d'automatisation des t√¢ches de trading"""
    
    def __init__(self, user: User):
        self.user = user
        self.broker_service = BrokerService(user)
        self.telegram_notifier = TelegramNotifier()
        self.config = self._get_or_create_config()
    
    def _get_or_create_config(self) -> AutomationConfig:
        """R√©cup√®re ou cr√©e la configuration d'automatisation"""
        config, created = AutomationConfig.objects.get_or_create(
            user=self.user,
            defaults={
                'is_active': False,
                'frequency_minutes': 30
            }
        )
        if created:
            logger.info(f"Configuration d'automatisation cr√©√©e pour {self.user.username}")
        return config
    
    def execute_automation_cycle(self) -> dict:
        """Ex√©cute un cycle complet d'automatisation"""
        start_time = timezone.now()
        logger.info(f"üöÄ D√©but du cycle d'automatisation pour {self.user.username}")
        
        # Notification de d√©but de cycle
        self.telegram_notifier.send_message(
            f"üöÄ **D√©but Cycle d'Automatisation**\n"
            f"üë§ {self.user.username}\n"
            f"‚è∞ {start_time.strftime('%H:%M:%S')}\n"
            f"üîÑ D√©marrage des synchronisations..."
        )
        
        # Initialiser les r√©sultats
        results = {
            'summary': [],
            'api_responses': [],
            'errors': [],
            'status': 'SUCCESS'
        }
        
        try:
            # 1. Synchronisation Binance
            results.update(self._sync_binance())
            
            # 2. Synchronisation Saxo
            results.update(self._sync_saxo())
            
            # 3. Ex√©cution des strat√©gies actives
            results.update(self._execute_active_strategies())
            
            # 4. Mettre √† jour la configuration
            self._update_execution_time()
            
            # 5. D√©terminer le statut final
            if results['errors']:
                results['status'] = 'PARTIAL' if results['summary'] else 'FAILED'
            
            # 6. Enregistrer le log
            self._save_execution_log(results, start_time)
            
            # 7. Envoyer les notifications Telegram
            self._send_telegram_notifications(results)
            
            # Notification de fin de cycle
            duration = timezone.now() - start_time
            duration_seconds = int(duration.total_seconds())
            
            self.telegram_notifier.send_message(
                f"üèÅ **Fin Cycle d'Automatisation**\n"
                f"üë§ {self.user.username}\n"
                f"‚è±Ô∏è Dur√©e: {duration_seconds}s\n"
                f"‚úÖ Succ√®s: {len(results['summary'])}\n"
                f"‚ùå Erreurs: {len(results['errors'])}\n"
                f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
            )
            
            logger.info(f"‚úÖ Cycle d'automatisation termin√© pour {self.user.username}")
            
        except Exception as e:
            error_msg = f"Erreur critique dans le cycle d'automatisation: {str(e)}"
            results['errors'].append(error_msg)
            results['status'] = 'FAILED'
            logger.error(error_msg, exc_info=True)
            
            # Enregistrer le log d'erreur
            self._save_execution_log(results, start_time)
            
            # Notifier l'erreur critique imm√©diatement
            self.telegram_notifier.send_error_notification(
                f"üí• **ERREUR CRITIQUE AUTOMATISATION**\n"
                f"üë§ {self.user.username}\n"
                f"üîç {error_msg}\n"
                f"‚è∞ {timezone.now().strftime('%H:%M:%S')}\n"
                f"üö® Cycle interrompu !"
            )
        
        return results
    
    def _sync_binance(self) -> dict:
        """Synchronise les donn√©es Binance"""
        results = {'summary': [], 'api_responses': [], 'errors': []}
        
        try:
            # R√©cup√©rer les credentials Binance
            binance_creds = BrokerCredentials.objects.filter(
                user=self.user,
                broker_type='binance',
                is_active=True
            ).first()
            
            if not binance_creds:
                results['summary'].append("‚ÑπÔ∏è Aucun broker Binance actif trouv√©")
                return results
            
            logger.info(f"üîÑ Synchronisation Binance pour {self.user.username}")
            
            # Synchroniser les positions
            try:
                positions = self.broker_service.sync_positions_from_broker(binance_creds)
                results['summary'].append(f"‚úÖ {len(positions)} positions Binance synchronis√©es")
                results['api_responses'].append(f"Positions Binance: {len(positions)} r√©cup√©r√©es")
                
                # Notification imm√©diate pour les positions
                self.telegram_notifier.send_message(
                    f"üîÑ **Synchronisation Binance - Positions**\n"
                    f"‚úÖ {len(positions)} positions synchronis√©es\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
                
            except Exception as e:
                error_msg = f"Erreur synchronisation positions Binance: {str(e)}"
                results['errors'].append(error_msg)
                logger.error(error_msg)
                
                # Notification d'erreur imm√©diate
                self.telegram_notifier.send_message(
                    f"‚ùå **Erreur Synchronisation Binance - Positions**\n"
                    f"üîç {error_msg}\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
            
            # Synchroniser les trades
            try:
                trades_result = self.broker_service.sync_trades_from_broker(binance_creds)
                if trades_result.get('success'):
                    results['summary'].append(f"‚úÖ {trades_result.get('count', 0)} trades Binance synchronis√©s")
                    results['api_responses'].append(f"Trades Binance: {trades_result.get('count', 0)} r√©cup√©r√©s")
                    
                    # Notification imm√©diate pour les trades
                    self.telegram_notifier.send_message(
                        f"üîÑ **Synchronisation Binance - Trades**\n"
                        f"‚úÖ {trades_result.get('count', 0)} trades synchronis√©s\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
                else:
                    results['errors'].append(f"√âchec synchronisation trades Binance: {trades_result.get('error', 'Erreur inconnue')}")
                    
                    # Notification d'erreur imm√©diate
                    self.telegram_notifier.send_message(
                        f"‚ùå **Erreur Synchronisation Binance - Trades**\n"
                        f"üîç {trades_result.get('error', 'Erreur inconnue')}\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
            except Exception as e:
                error_msg = f"Erreur synchronisation trades Binance: {str(e)}"
                results['errors'].append(error_msg)
                logger.error(error_msg)
                
                # Notification d'erreur imm√©diate
                self.telegram_notifier.send_message(
                    f"‚ùå **Erreur Synchronisation Binance - Trades**\n"
                    f"üîç {error_msg}\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
                
        except Exception as e:
            error_msg = f"Erreur g√©n√©rale synchronisation Binance: {str(e)}"
            results['errors'].append(error_msg)
            logger.error(error_msg)
        
        return results
    
    def _sync_saxo(self) -> dict:
        """Synchronise les donn√©es Saxo"""
        results = {'summary': [], 'api_responses': [], 'errors': []}
        
        try:
            # R√©cup√©rer les credentials Saxo
            saxo_creds = BrokerCredentials.objects.filter(
                user=self.user,
                broker_type='saxo',
                is_active=True
            ).first()
            
            if not saxo_creds:
                results['summary'].append("‚ÑπÔ∏è Aucun broker Saxo actif trouv√©")
                return results
            
            logger.info(f"üîÑ Synchronisation Saxo pour {self.user.username}")
            
            # Synchroniser les positions
            try:
                positions = self.broker_service.sync_positions_from_broker(saxo_creds)
                results['summary'].append(f"‚úÖ {len(positions)} positions Saxo synchronis√©es")
                results['api_responses'].append(f"Positions Saxo: {len(positions)} r√©cup√©r√©es")
                
                # Notification imm√©diate pour les positions
                self.telegram_notifier.send_message(
                    f"üîÑ **Synchronisation Saxo - Positions**\n"
                    f"‚úÖ {len(positions)} positions synchronis√©es\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
                
            except Exception as e:
                error_msg = f"Erreur synchronisation positions Saxo: {str(e)}"
                results['errors'].append(error_msg)
                logger.error(error_msg)
                
                # Notification d'erreur imm√©diate
                self.telegram_notifier.send_message(
                    f"‚ùå **Erreur Synchronisation Saxo - Positions**\n"
                    f"üîç {error_msg}\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
            
            # Synchroniser les trades
            try:
                trades_result = self.broker_service.sync_trades_from_broker(saxo_creds)
                if trades_result.get('success'):
                    results['summary'].append(f"‚úÖ {trades_result.get('count', 0)} trades Saxo synchronis√©s")
                    results['summary'].append(f"‚úÖ {trades_result.get('count', 0)} trades Saxo synchronis√©s")
                    results['api_responses'].append(f"Trades Saxo: {trades_result.get('count', 0)} r√©cup√©r√©s")
                    
                    # Notification imm√©diate pour les trades
                    self.telegram_notifier.send_message(
                        f"üîÑ **Synchronisation Saxo - Trades**\n"
                        f"‚úÖ {trades_result.get('count', 0)} trades synchronis√©s\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
                else:
                    results['errors'].append(f"√âchec synchronisation trades Saxo: {trades_result.get('error', 'Erreur inconnue')}")
                    
                    # Notification d'erreur imm√©diate
                    self.telegram_notifier.send_error_notification(
                        f"‚ùå **Erreur Synchronisation Saxo - Trades**\n"
                        f"üîç {trades_result.get('error', 'Erreur inconnue')}\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
            except Exception as e:
                error_msg = f"Erreur synchronisation trades Saxo: {str(e)}"
                results['errors'].append(error_msg)
                logger.error(error_msg)
                
                # Notification d'erreur imm√©diate
                self.telegram_notifier.send_error_notification(
                    f"‚ùå **Erreur Synchronisation Saxo - Trades**\n"
                    f"üîç {error_msg}\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
            
            # Auto-refresh des tokens Saxo (si activ√©)
            if self.config.auto_refresh_tokens:
                try:
                    # Refresh syst√©matique des tokens Saxo √† chaque cycle
                    success = self.broker_service.refresh_saxo_tokens(saxo_creds)
                    if success:
                        results['summary'].append("‚úÖ Tokens Saxo rafra√Æchis")
                        results['api_responses'].append("Refresh tokens Saxo: Succ√®s")
                        
                        # Notification imm√©diate pour le refresh des tokens
                        self.telegram_notifier.send_message(
                            f"üîÑ **Refresh Tokens Saxo**\n"
                            f"‚úÖ Tokens rafra√Æchis avec succ√®s\n"
                            f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                        )
                    else:
                        results['errors'].append("√âchec du refresh des tokens Saxo")
                        
                        # Notification d'erreur imm√©diate
                        self.telegram_notifier.send_message(
                            f"‚ùå **Erreur Refresh Tokens Saxo**\n"
                            f"üîç √âchec du refresh des tokens\n"
                            f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                        )
                except Exception as e:
                    error_msg = f"Erreur refresh tokens Saxo: {str(e)}"
                    results['errors'].append(error_msg)
                    logger.error(error_msg)
                    
                    # Notification d'erreur imm√©diate
                    self.telegram_notifier.send_message(
                        f"‚ùå **Erreur Refresh Tokens Saxo**\n"
                        f"üîç {error_msg}\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
            else:
                results['summary'].append("‚ÑπÔ∏è Refresh automatique des tokens d√©sactiv√©")
                
                # Notification d'information
                self.telegram_notifier.send_message(
                    f"‚ÑπÔ∏è **Refresh Tokens Saxo**\n"
                    f"üìã Refresh automatique d√©sactiv√© par l'utilisateur\n"
                    f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                )
                
        except Exception as e:
            error_msg = f"Erreur g√©n√©rale synchronisation Saxo: {str(e)}"
            results['errors'].append(error_msg)
            logger.error(error_msg)
        
        return results
    
    def _execute_active_strategies(self) -> dict:
        """Ex√©cute les strat√©gies actives"""
        results = {'summary': [], 'api_responses': [], 'errors': []}
        
        try:
            # R√©cup√©rer les strat√©gies actives (status = 'ACTIVE')
            active_strategies = Strategy.objects.filter(
                user=self.user,
                status='ACTIVE'
            )
            
            if not active_strategies.exists():
                results['summary'].append("‚ÑπÔ∏è Aucune strat√©gie active trouv√©e")
                return results
            
            logger.info(f"üöÄ Ex√©cution de {active_strategies.count()} strat√©gies actives pour {self.user.username}")
            
            executed_count = 0
            for strategy in active_strategies:
                try:
                    # Ex√©cuter la strat√©gie
                    from .views import execute_strategy
                    result = execute_strategy(strategy.id)
                    
                    if result.get('success'):
                        executed_count += 1
                        results['summary'].append(f"‚úÖ Strat√©gie {strategy.name} ex√©cut√©e")
                        results['api_responses'].append(f"Strat√©gie {strategy.name}: {result.get('message', 'Succ√®s')}")
                        
                        # Notification imm√©diate pour l'ex√©cution r√©ussie
                        self.telegram_notifier.send_message(
                            f"üöÄ **Ex√©cution Strat√©gie**\n"
                            f"‚úÖ {strategy.name} ex√©cut√©e avec succ√®s\n"
                            f"üìä {result.get('message', 'Succ√®s')}\n"
                            f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                        )
                    else:
                        results['errors'].append(f"√âchec ex√©cution strat√©gie {strategy.name}: {result.get('error', 'Erreur inconnue')}")
                        
                        # Notification d'erreur imm√©diate
                        self.telegram_notifier.send_error_notification(
                            f"‚ùå **Erreur Ex√©cution Strat√©gie**\n"
                            f"üîç {strategy.name}: {result.get('error', 'Erreur inconnue')}\n"
                            f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                        )
                        
                except Exception as e:
                    error_msg = f"Erreur ex√©cution strat√©gie {strategy.name}: {str(e)}"
                    results['errors'].append(error_msg)
                    logger.error(error_msg)
                    
                    # Notification d'erreur imm√©diate
                    self.telegram_notifier.send_error_notification(
                        f"‚ùå **Erreur Critique Ex√©cution Strat√©gie**\n"
                        f"üîç {strategy.name}: {error_msg}\n"
                        f"‚è∞ {timezone.now().strftime('%H:%M:%S')}"
                    )
                    continue  # Continuer avec les autres strat√©gies
            
            if executed_count > 0:
                results['summary'].append(f"‚úÖ {executed_count}/{active_strategies.count()} strat√©gies ex√©cut√©es avec succ√®s")
            else:
                results['summary'].append("‚ö†Ô∏è Aucune strat√©gie n'a pu √™tre ex√©cut√©e")
                
        except Exception as e:
            error_msg = f"Erreur g√©n√©rale ex√©cution strat√©gies: {str(e)}"
            results['errors'].append(error_msg)
            logger.error(error_msg)
        
        return results
    
    def _update_execution_time(self):
        """Met √† jour les temps d'ex√©cution"""
        now = timezone.now()
        self.config.last_execution = now
        self.config.next_execution = self.config.calculate_next_execution()
        self.config.save()
    
    def _save_execution_log(self, results: dict, start_time: datetime):
        """Sauvegarde le log d'ex√©cution"""
        try:
            execution_duration = timezone.now() - start_time
            
            AutomationExecutionLog.objects.create(
                user=self.user,
                status=results['status'],
                summary='\n'.join(results['summary']) if results['summary'] else 'Aucune action effectu√©e',
                api_responses='\n'.join(results['api_responses']) if results['api_responses'] else 'Aucune r√©ponse API',
                errors='\n'.join(results['errors']) if results['errors'] else '',
                execution_duration=execution_duration
            )
            
            logger.info(f"Log d'ex√©cution sauvegard√© pour {self.user.username}")
            
        except Exception as e:
            logger.error(f"Erreur sauvegarde log d'ex√©cution: {str(e)}")
    
    def _send_telegram_notifications(self, results: dict):
        """Envoie les notifications Telegram"""
        try:
            # Message 1: R√©sum√© des actions
            if results['summary']:
                summary_msg = "üîÑ **R√©sum√© de l'Automatisation**\n\n" + '\n'.join(results['summary'])
                self.telegram_notifier.send_message(summary_msg)
            
            # Message 2: R√©ponses des APIs
            if results['api_responses']:
                api_msg = "üìä **R√©ponses des APIs**\n\n" + '\n'.join(results['api_responses'])
                self.telegram_notifier.send_message(api_msg)
            
            # Message 3: Erreurs
            if results['errors']:
                error_msg = "‚ùå **Erreurs Rencontr√©es**\n\n" + '\n'.join(results['errors'])
                self.telegram_notifier.send_error_notification(error_msg)
            
            logger.info(f"Notifications Telegram envoy√©es pour {self.user.username}")
            
        except Exception as e:
            logger.error(f"Erreur envoi notifications Telegram: {str(e)}")
    
    def start_automation(self):
        """D√©marre l'automatisation"""
        self.config.is_active = True
        self.config.save()
        logger.info(f"Automatisation d√©marr√©e pour {self.user.username}")
    
    def stop_automation(self):
        """Arr√™te l'automatisation"""
        self.config.is_active = False
        self.config.save()
        logger.info(f"Automatisation arr√™t√©e pour {self.user.username}")
    
    def pause_automation(self):
        """Met en pause l'automatisation"""
        self.config.is_active = False
        self.config.save()
        logger.info(f"Automatisation mise en pause pour {self.user.username}")
    
    def resume_automation(self):
        """Reprend l'automatisation"""
        self.config.is_active = True
        self.config.save()
        logger.info(f"Automatisation reprise pour {self.user.username}")
    
    def update_frequency(self, frequency_minutes: int):
        """Met √† jour la fr√©quence d'ex√©cution"""
        self.config.frequency_minutes = frequency_minutes
        self.config.save()
        logger.info(f"Fr√©quence d'automatisation mise √† jour: {frequency_minutes} minutes pour {self.user.username}")
    
    def toggle_auto_refresh_tokens(self, enabled: bool):
        """Active/d√©sactive le refresh automatique des tokens"""
        self.config.auto_refresh_tokens = enabled
        self.config.save()
        status = "activ√©" if enabled else "d√©sactiv√©"
        logger.info(f"Refresh automatique des tokens {status} pour {self.user.username}")
    
    def get_status(self) -> dict:
        """Retourne le statut de l'automatisation"""
        return {
            'is_active': self.config.is_active,
            'frequency_minutes': self.config.frequency_minutes,
            'auto_refresh_tokens': self.config.auto_refresh_tokens,
            'last_execution': self.config.last_execution,
            'next_execution': self.config.next_execution,
            'created_at': self.config.created_at,
            'updated_at': self.config.updated_at
        }
    

